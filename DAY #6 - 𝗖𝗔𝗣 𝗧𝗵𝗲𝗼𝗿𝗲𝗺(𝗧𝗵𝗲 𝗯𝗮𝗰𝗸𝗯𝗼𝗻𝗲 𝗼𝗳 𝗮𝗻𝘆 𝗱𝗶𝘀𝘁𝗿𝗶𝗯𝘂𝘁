DAY #6 - ð—–ð—”ð—£ ð—§ð—µð—²ð—¼ð—¿ð—²ð—º(ð—§ð—µð—² ð—¯ð—®ð—°ð—¸ð—¯ð—¼ð—»ð—² ð—¼ð—³ ð—®ð—»ð˜† ð—±ð—¶ð˜€ð˜ð—¿ð—¶ð—¯ð˜‚ð˜ð—²ð—± ð˜€ð˜†ð˜€ð˜ð—²ð—º) - ð—£ð—®ð—¿ð˜(ðŸ­):
Breaking the working of CAP theorem into 2 parts. Will cover the basics in this part and examples and implementations in the 2nd part.

So this is the abc of any distributed system.

lets break down "CAP":

ð‘ªð’ð’ð’”ð’Šð’”ð’•ð’†ð’ð’„ð’š -> Every read gets the most recent write. as simple as that. As soon as any update query hits and the data is being read.(Do not confuse it with the transaction isolation, everything we are talking here is after commit).

simple eg - you paid 200 Rs to your friend, that 200 Rs will get updated in his bank acc and will reflect all around consistently. So any updates which is of transaction in nature will have strong consistency.

ð‘¨ð’—ð’‚ð’Šð’ð’‚ð’ƒð’Šð’ð’Šð’•ð’š -> Every read should get a response, It may not have the most recent write. That is, just after write, it is possible that some data nodes hold different info for some time, because the call goes asynchronously.

simple eg - You are viewing a a movie on Netflix. The data availability plays the most important role here, a microsecond data loss holds no issue here.

ð‘µð’ð’•ð’† - if the data is something which holds a lot of transactional importance, it needs to be consistent. On the other hand, if the data needs to be there all the time, though eventually consistent gives availability the priority.

Partition Tolerance - Every distributed system has some nodes, now it is possible that some data node fails, in such scenarios, will the system continue to operate? This is measured in partition tolerance.

ð—–ð—”ð—£ ð˜ð—µð—²ð—¼ð—¿ð—²ð—º ð˜€ð˜ð—®ð˜ð—²ð˜€, ð˜†ð—¼ð˜‚ ð—°ð—®ð—» ð—¼ð—»ð—¹ð˜† ð—µð—®ð˜ƒð—² ðŸ® ð—¼ð—³ ð—®ð—¹ð—¹ ð˜ð—µð—² ð—½ð—¼ð˜€ð˜€ð—¶ð—¯ð—¹ð—² ð—°ð—¼ð—ºð—¯ð—¶ð—»ð—®ð˜ð—¶ð—¼ð—»ð˜€ ð—¼ð—³ 'ð—–','ð—”' ð—®ð—»ð—± 'ð—£':

ð‘ª ð’‚ð’ð’… ð‘¨ ð’ƒð’–ð’• ð’ð’ð’• ð‘· (ð’ð’ð’• ð’…ð’Šð’”ð’•ð’“ð’Šð’ƒð’–ð’•ð’†ð’…)-> A single node server running a relational database with vertical scaling. Gives consistency, Availability but 0 partition tolerance. The system will fail if the node breaks.

ð˜¾ ð˜¼ð™‰ð˜¿ ð™‹ ð™—ð™ªð™© ð™£ð™¤ð™© ð˜¼ -> Remember NoSQL databases that can have high consistency, Those system fall in this category, you can have a distibuted system here, But the availability is compromised. Classic example - MongoDB.

ð‘¨ ð‘¨ð‘µð‘« ð‘· ð’ƒð’–ð’• ð’ð’ð’• ð‘ª (ð’Žð’‚ð’‹ð’ð’“ð’Šð’•ð’š ð’ð’‡ ð‘µð’ð‘ºð‘¸ð‘³ ð‘«ð‘©'ð’”) -> Highly distributed systems serving huge number of data per second. Data availability with network failure tolerance is the main key here. Classic example - Cassandra.

Again, you have to pick your use case and apply the strategy. Logic remains the same, always.

Will try and cover some examples and implementations tomorrow.

peace âœŒ