Day #4 - ğ‡ğ¨ğ° ğ«ğğšğ ğšğ§ğ ğ°ğ«ğ¢ğ­ğ ğ¡ğšğ©ğ©ğğ§ğ¬ ğ¢ğ§ ğ‘ğğ¥ğšğ­ğ¢ğ¨ğ§ğšğ¥ ğğšğ­ğšğ›ğšğ¬ğğ¬(ğš ğœğšğ¬ğ ğ¬ğ­ğ®ğğ² ğ¨ğ§ ğ+ ğ­ğ«ğğğ¬):
Efficient read and write in relational databases occur using B+ trees. Lets go through B+ trees in very short.

B+ trees are advanced balancing m-ary tree with left node < root node and right node > root node(consider it a self balancing BST(AVL tree) but with m children). It holds 2 key info in a node:-
1) pointer to nodes
2) value of the node

pointer holds the address of the child nodes(for a non leaf node) and address to the neighouring node(for a leaf node). This allows downward traversal in non-leaf nodes and sideways traversal in leaf nodes facilitating range queries. look at the image below and the structure will be crystal clear.

Now lets see how it increases the efficiency of the CRUD operations:-

lets say we run:-
select * from employee where id = "1000";

Now lazy fetch would process like, we would go through each and every row and check the where clause. This will take O(n) OR linear time complexity and reduces efficiency a lot.

what would happen if we use:-
ğ‘ªğ‘¹ğ‘¬ğ‘¨ğ‘»ğ‘¬ ğ‘°ğ‘µğ‘«ğ‘¬ğ‘¿ ğ’Šğ’…ğ’™_ğ’Šğ’… ğ’ğ’ ğ’†ğ’ğ’‘ğ’ğ’ğ’šğ’†ğ’†(ğ’Šğ’…);(ğ’ğ’ ğ‘´ğ’šğ‘ºğ‘¸ğ‘³)

OR

@ğ‘»ğ’‚ğ’ƒğ’ğ’†(ğ’ğ’‚ğ’ğ’† = "ğ’†ğ’ğ’‘ğ’ğ’ğ’šğ’†ğ’†", ğ’Šğ’ğ’…ğ’†ğ’™ğ’†ğ’” = {@ğ‘°ğ’ğ’…ğ’†ğ’™(ğ’ğ’‚ğ’ğ’† = "ğ’Šğ’…ğ’™_ğ’Šğ’…", ğ’„ğ’ğ’ğ’–ğ’ğ’ğ‘³ğ’Šğ’”ğ’• = "ğ’Šğ’…")}) (ğ’‚ğ’ğ’ğ’ğ’•ğ’‚ğ’•ğ’Šğ’ğ’ ğ’ğ’ ğ’•ğ’ğ’‘ ğ’ğ’‡ ğ‘¬ğ’ğ’‘ğ’ğ’ğ’šğ’†ğ’† ğ’…ğ’ğ’ğ’‚ğ’Šğ’)

This would create a B+ tree element. Now as soon as any new element is added, it gets added in the leaf of the B+ tree, tree is balanced and upward propagation takes place(this is a standard algorithm of self balancing upon element insertion).

Now our job is done.

Now its just data structures and algorithms (a practical example for the people who ask where do I use data structure and algorithm in dev. ğŸ˜œ )

CRUD operations happens in ğ’ğ’ğ’ˆ(ğ’) and our efficiency is increased. Very efficient for Range queries.

Question -> If this approach is so good with CRUD, then why NoSQL databases are required? Why cant we use this for searching instead of a NoSQL database like elastic search?

Lets get the answer tomorrow.

ğ—¡ğ—¼ğ˜ğ—² :- B- Trees are used for single indexing while B+ trees are used for composite indexing.

Day #5(tomorrow) - ğ—œğ—»ğ˜ğ—¿ğ—¼ğ—±ğ˜‚ğ—°ğ˜ğ—¶ğ—¼ğ—» ğ˜ğ—¼ ğ—¡ğ—¼ğ—¦ğ—¤ğ—Ÿ

Some good references for detail reading:-

ğ‘ªğ‘¹ğ‘¼ğ‘« ğ’ğ’ ğ‘©-ğ’•ğ’“ğ’†ğ’†ğ’” - https://lnkd.in/gyEm358X

ğ‘ªğ’ğ’ğ’‘ğ’ğ’”ğ’Šğ’•ğ’† ğ‘°ğ’ğ’…ğ’†ğ’™ğ’Šğ’ğ’ˆ ğ’Šğ’ ğ‘´ğ’šğ‘ºğ‘¸ğ‘³ - https://lnkd.in/gXxjqsZD